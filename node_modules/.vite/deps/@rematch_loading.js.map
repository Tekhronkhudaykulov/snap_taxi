{
  "version": 3,
  "sources": ["../../@rematch/loading/src/index.ts"],
  "sourcesContent": ["import {\n\tExtractRematchDispatchersFromEffects,\n\tPlugin,\n\tModels,\n\tReducer,\n\tNamedModel,\n\tAction,\n} from '@rematch/core'\n\nexport type LoadingPluginType = 'number' | 'boolean' | 'full'\nexport interface LoadingConfig {\n\tname?: string\n\twhitelist?: string[]\n\tblacklist?: string[]\n\ttype?: LoadingPluginType\n\t/**\n\t * @deprecated Use `type: 'number'` instead\n\t */\n\tasNumber?: boolean\n}\ntype PickLoadingPluginType<WhichType extends LoadingPluginType> =\n\tWhichType extends 'number'\n\t\t? number\n\t\t: WhichType extends 'full'\n\t\t? DetailedPayload\n\t\t: boolean\n\ninterface LoadingState<\n\tTModels extends Models<TModels>,\n\tWhichType extends LoadingPluginType\n> {\n\tglobal: PickLoadingPluginType<WhichType>\n\tmodels: {\n\t\t[modelName in keyof TModels]: PickLoadingPluginType<WhichType>\n\t}\n\teffects: {\n\t\t[modelName in keyof TModels]: {\n\t\t\t[effectName in keyof ExtractRematchDispatchersFromEffects<\n\t\t\t\tTModels[modelName]['effects'],\n\t\t\t\tTModels\n\t\t\t>]: PickLoadingPluginType<WhichType>\n\t\t}\n\t}\n}\n\ninterface InitialState<WhichType extends LoadingPluginType> {\n\tglobal: PickLoadingPluginType<WhichType>\n\tmodels: {\n\t\t[modelName: string]: PickLoadingPluginType<WhichType>\n\t}\n\teffects: {\n\t\t[modelName: string]: {\n\t\t\t[effectName: string]: PickLoadingPluginType<WhichType>\n\t\t}\n\t}\n}\n\ntype Converter<WhichType extends LoadingPluginType> = (\n\tcnt: number,\n\tdetailedPayload?: DetailedPayload\n) => PickLoadingPluginType<WhichType>\n\ninterface LoadingModel<\n\tTModels extends Models<TModels>,\n\tWhichType extends LoadingPluginType\n> extends NamedModel<TModels, LoadingState<TModels, WhichType>> {\n\treducers: {\n\t\thide: Reducer<LoadingState<TModels, WhichType>>\n\t\tshow: Reducer<LoadingState<TModels, WhichType>>\n\t}\n}\n\nexport interface ExtraModelsFromLoading<\n\tTModels extends Models<TModels>,\n\tTConfig extends LoadingConfig = {\n\t\ttype: 'boolean'\n\t}\n> extends Models<TModels> {\n\tloading: LoadingModel<\n\t\tTModels,\n\t\tTConfig['type'] extends LoadingPluginType ? TConfig['type'] : 'boolean'\n\t>\n}\n\ntype DetailedPayload = {\n\terror: unknown\n\tsuccess: boolean\n\tloading?: boolean\n}\n\nconst createLoadingAction =\n\t<TModels extends Models<TModels>, WhichType extends LoadingPluginType>(\n\t\tconverter: Converter<WhichType>,\n\t\ti: number,\n\t\tcntState: InitialState<'number'>\n\t): Reducer<LoadingState<TModels, WhichType>> =>\n\t(\n\t\tstate,\n\t\tpayload: Action<{\n\t\t\tname: string\n\t\t\taction: string\n\t\t\tdetailedPayload: DetailedPayload\n\t\t}>['payload']\n\t): LoadingState<TModels, WhichType> => {\n\t\tconst { name, action, detailedPayload } = payload || {\n\t\t\tname: '',\n\t\t\taction: '',\n\t\t}\n\n\t\tcntState.global += i\n\t\tcntState.models[name] += i\n\t\tcntState.effects[name][action] += i\n\n\t\treturn {\n\t\t\t...state,\n\t\t\tglobal: converter(cntState.global, detailedPayload),\n\t\t\tmodels: {\n\t\t\t\t...state.models,\n\t\t\t\t[name]: converter(cntState.models[name], detailedPayload),\n\t\t\t},\n\t\t\teffects: {\n\t\t\t\t...state.effects,\n\t\t\t\t[name]: {\n\t\t\t\t\t...state.effects[name],\n\t\t\t\t\t[action]: converter(cntState.effects[name][action], detailedPayload),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\nconst validateConfig = (config: LoadingConfig): void => {\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tif (config.name && typeof config.name !== 'string') {\n\t\t\tthrow new Error('loading plugin config name must be a string')\n\t\t}\n\t\tif (config.asNumber && typeof config.asNumber !== 'boolean') {\n\t\t\tthrow new Error('loading plugin config asNumber must be a boolean')\n\t\t}\n\t\tif (config.asNumber) {\n\t\t\tconsole.warn(\n\t\t\t\t[\n\t\t\t\t\t'@rematch/loading deprecation warning:',\n\t\t\t\t\t'\\n',\n\t\t\t\t\t'\"asNumber\" property from @rematch/loading is deprecated, consider replacing \"asNumber\" to \"type\": \"number\".',\n\t\t\t\t\t'\\n',\n\t\t\t\t\t'In future Rematch versions, \"asNumber\" will be removed.',\n\t\t\t\t].join(' ')\n\t\t\t)\n\t\t}\n\t\tif (config.whitelist && !Array.isArray(config.whitelist)) {\n\t\t\tthrow new Error(\n\t\t\t\t'loading plugin config whitelist must be an array of strings'\n\t\t\t)\n\t\t}\n\t\tif (config.blacklist && !Array.isArray(config.blacklist)) {\n\t\t\tthrow new Error(\n\t\t\t\t'loading plugin config blacklist must be an array of strings'\n\t\t\t)\n\t\t}\n\t\tif (config.whitelist && config.blacklist) {\n\t\t\tthrow new Error(\n\t\t\t\t'loading plugin config cannot have both a whitelist & a blacklist'\n\t\t\t)\n\t\t}\n\t}\n}\n\nfunction assignExtraPayload<T, B>(insert: boolean, error: T, success: B) {\n\treturn insert ? { error, success } : null\n}\n\nexport default <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tTConfig extends LoadingConfig\n>(\n\tconfig: TConfig = {} as TConfig\n): Plugin<\n\tTModels,\n\tTExtraModels,\n\tExtraModelsFromLoading<\n\t\tTModels,\n\t\tTConfig extends LoadingConfig ? TConfig : { type: 'boolean' }\n\t>\n> => {\n\tvalidateConfig(config)\n\n\tconst loadingModelName = config.name || 'loading'\n\tif (config.asNumber) {\n\t\tconfig.type = 'number'\n\t}\n\tconst isAsNumber = config.type === 'number'\n\tconst isAsDetailed = config.type === 'full'\n\n\tconst converter: Converter<LoadingPluginType> = (cnt, detailedPayload) => {\n\t\tif (isAsNumber) return cnt\n\t\tif (isAsDetailed && detailedPayload) {\n\t\t\treturn { ...detailedPayload, loading: cnt > 0 } as DetailedPayload\n\t\t}\n\t\tif (isAsDetailed) {\n\t\t\treturn { loading: cnt > 0, success: false, error: false }\n\t\t}\n\t\treturn cnt > 0\n\t}\n\n\tconst loadingInitialState: InitialState<LoadingPluginType> = {\n\t\tglobal: converter(0),\n\t\tmodels: {},\n\t\teffects: {},\n\t}\n\n\tconst cntState: InitialState<'number'> = {\n\t\tglobal: 0,\n\t\tmodels: {},\n\t\teffects: {},\n\t}\n\tconst loading: LoadingModel<TModels, LoadingPluginType> = {\n\t\tname: loadingModelName,\n\t\treducers: {\n\t\t\thide: createLoadingAction(converter, -1, cntState),\n\t\t\tshow: createLoadingAction(converter, 1, cntState),\n\t\t},\n\t\tstate: loadingInitialState as LoadingState<TModels, LoadingPluginType>,\n\t}\n\n\tconst initialLoadingValue = converter(0)\n\n\treturn {\n\t\tconfig: {\n\t\t\tmodels: {\n\t\t\t\tloading,\n\t\t\t},\n\t\t},\n\t\tonModel({ name }, rematch): void {\n\t\t\t// do not run dispatch on \"loading\" model\n\t\t\tif (name === loadingModelName) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tcntState.models[name] = 0\n\t\t\tcntState.effects[name] = {}\n\n\t\t\tloadingInitialState.models[name] = initialLoadingValue as number\n\t\t\tloadingInitialState.effects[name] = {}\n\n\t\t\tconst modelActions = rematch.dispatch[name]\n\n\t\t\t// map over effects within models\n\t\t\tObject.keys(modelActions).forEach((action: string) => {\n\t\t\t\tif (rematch.dispatch[name][action].isEffect === false) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tcntState.effects[name][action] = 0\n\t\t\t\tloadingInitialState.effects[name][action] =\n\t\t\t\t\tinitialLoadingValue as number\n\n\t\t\t\tconst actionType = `${name}/${action}`\n\n\t\t\t\t// ignore items not in whitelist\n\t\t\t\tif (config.whitelist && !config.whitelist.includes(actionType)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// ignore items in blacklist\n\t\t\t\tif (config.blacklist && config.blacklist.includes(actionType)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// copy orig effect pointer\n\t\t\t\tconst origEffect = rematch.dispatch[name][action]\n\n\t\t\t\t// create function with pre & post loading calls\n\t\t\t\tconst effectWrapper = (...props: any): any => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// show loading\n\t\t\t\t\t\trematch.dispatch[loadingModelName].show({\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\taction,\n\t\t\t\t\t\t\tdetailedPayload: assignExtraPayload(isAsDetailed, false, false),\n\t\t\t\t\t\t})\n\t\t\t\t\t\t// dispatch the original action\n\t\t\t\t\t\tconst effectResult = origEffect(...props)\n\n\t\t\t\t\t\t// check if result is a promise\n\t\t\t\t\t\tif (effectResult?.then) {\n\t\t\t\t\t\t\t// hide loading when promise finishes either with success or error\n\t\t\t\t\t\t\treturn effectResult\n\t\t\t\t\t\t\t\t.then((r: any) => {\n\t\t\t\t\t\t\t\t\trematch.dispatch[loadingModelName].hide({\n\t\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\t\taction,\n\t\t\t\t\t\t\t\t\t\tdetailedPayload: assignExtraPayload(\n\t\t\t\t\t\t\t\t\t\t\tisAsDetailed,\n\t\t\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\treturn r\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.catch((err: any) => {\n\t\t\t\t\t\t\t\t\trematch.dispatch[loadingModelName].hide({\n\t\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\t\taction,\n\t\t\t\t\t\t\t\t\t\tdetailedPayload: assignExtraPayload(\n\t\t\t\t\t\t\t\t\t\t\tisAsDetailed,\n\t\t\t\t\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\tthrow err\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// original action doesn't return a promise so there's nothing to wait for\n\t\t\t\t\t\trematch.dispatch[loadingModelName].hide({\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\taction,\n\t\t\t\t\t\t\tdetailedPayload: assignExtraPayload(isAsDetailed, false, true),\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\t// return the original result of this reducer\n\t\t\t\t\t\treturn effectResult\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\trematch.dispatch[loadingModelName].hide({\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\taction,\n\t\t\t\t\t\t\tdetailedPayload: assignExtraPayload(isAsDetailed, error, false),\n\t\t\t\t\t\t})\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\teffectWrapper.isEffect = true\n\n\t\t\t\t// replace existing effect with new wrapper\n\t\t\t\trematch.dispatch[name][action] = effectWrapper\n\t\t\t})\n\t\t},\n\t}\n}\n"],
  "mappings": "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",
  "names": ["createLoadingAction", "converter", "i", "cntState", "state", "payload", "name", "action", "detailedPayload", "global", "models", "effects", "validateConfig", "config", "process", "Error", "asNumber", "console", "warn", "join", "whitelist", "Array", "isArray", "blacklist", "assignExtraPayload", "insert", "error", "success", "loadingModelName", "type", "isAsNumber", "isAsDetailed", "cnt", "loading", "loadingInitialState", "reducers", "hide", "show", "initialLoadingValue", "onModel", "rematch", "modelActions", "dispatch", "Object", "keys", "forEach", "isEffect", "actionType", "includes", "origEffect", "effectWrapper", "effectResult", "then", "r", "err"]
}
